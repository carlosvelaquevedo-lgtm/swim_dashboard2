# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1McUyCbG1Oaz34jMhNBfkNuToxkYt7CAE
"""

# app.py
# Freestyle Swimming Technique Analyzer – Streamlit version

import streamlit as st
import cv2
import numpy as np
import mediapipe as mp
from mediapipe.tasks import python
from mediapipe.tasks.python import vision
import os
import datetime
import csv
import statistics
from collections import deque
import urllib.request
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import io
import tempfile

# ── Helper functions (unchanged) ──
def angle(a, b, c):
    ba = np.array(a) - np.array(b)
    bc = np.array(c) - np.array(b)
    cosine = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc) + 1e-8)
    return np.degrees(np.arccos(np.clip(cosine, -1.0, 1.0)))

def deviation(val, ideal_range):
    lo, hi = ideal_range
    if val < lo: return lo - val
    if val > hi: return val - hi
    return 0.0

def local_min_center(window, prom=10.0):
    if len(window) < 3: return False, None
    c = len(window) // 2
    v = window[c]
    return (
        all(v <= window[i] + prom for i in range(c)) and
        all(v <= window[i] + prom for i in range(c, len(window)))
    ), v

def signed_yaw_proxy(nose, ls, rs):
    dx = rs[0] - ls[0]
    if abs(dx) < 1e-6:
        return 0.0
    expected = ls[0] + 0.5 * dx
    return (nose[0] - expected) / (abs(dx) + 1e-6)

# ── Configuration ──
IS_UNDERWATER = False
SMOOTHING_WINDOW = 7
ELBOW_MIN_WINDOW = 9
ELBOW_MIN_PROM = 10.0
MIN_STROKE_GAP_S = 0.5
BREATH_SIDE_THRESH = 0.15
MIN_BREATH_GAP_S = 1.0
MIN_BREATH_HOLD_FRAMES = 4

IDEAL_ELBOW = (70,120) if IS_UNDERWATER else (80,140)
IDEAL_KNEE  = (150,175) if IS_UNDERWATER else (155,175)

# ── Download model if needed ──
@st.cache_resource
def get_detector():
    MODEL = "pose_landmarker_heavy.task"
    URL = "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/latest/pose_landmarker_heavy.task"

    if not os.path.exists(MODEL):
        with st.spinner("Downloading MediaPipe model (~100 MB) ... first run only"):
            urllib.request.urlretrieve(URL, MODEL)

    options = vision.PoseLandmarkerOptions(
        base_options=python.BaseOptions(model_asset_path=MODEL),
        running_mode=vision.RunningMode.VIDEO,
        num_poses=1,
        min_pose_detection_confidence=0.6,
        min_pose_presence_confidence=0.6,
        min_tracking_confidence=0.6
    )
    return vision.PoseLandmarker.create_from_options(options)

# ── Streamlit UI ──
st.title("Freestyle Swimming Technique Analyzer")
st.markdown("Upload a front/side view freestyle swimming video (preferably above-water).  \nThe app will annotate strokes, breathing, elbow angles, symmetry and give a rough technique score.")

uploaded_file = st.file_uploader("Upload swimming video", type=["mp4", "mov", "avi"])

if uploaded_file is not None:
    st.success("Video uploaded! Click **Analyze** to start processing.")

    if st.button("Analyze Video (may take 1–10 min depending on length)"):
        with st.spinner("Processing video..."):
            # Save uploaded file temporarily
            with tempfile.NamedTemporaryFile(delete=False, suffix=".mp4") as tmp_in:
                tmp_in.write(uploaded_file.read())
                VIDEO_PATH = tmp_in.name

            detector = get_detector()

            cap = cv2.VideoCapture(VIDEO_PATH)
            fps = cap.get(cv2.CAP_PROP_FPS) or 30
            w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            csv_buffer = io.StringIO()
            frames_processed = 0

            # Data storage (same as original)
            times, elbow_vals, kl_vals, kr_vals = [], [], [], []
            sym_vals, scores, yaw_series, breath_state_series = [], [], [], []

            elbow_buf = deque(maxlen=SMOOTHING_WINDOW)
            kl_buf  = deque(maxlen=SMOOTHING_WINDOW)
            kr_buf  = deque(maxlen=SMOOTHING_WINDOW)
            score_buf = deque(maxlen=5)

            elbow_win = deque(maxlen=ELBOW_MIN_WINDOW | 1)
            time_win  = deque(maxlen=ELBOW_MIN_WINDOW | 1)
            stroke_times = []

            last_breath_time = -1e9
            breath_count_L = breath_count_R = 0
            current_side = 'N'
            side_persist = 0

            NOSE, LSH, RSH = 0, 11, 12
            LEL, LWR = 13, 15
            LHP, LKN, LAK = 23, 25, 27
            RHP, RKN, RAK = 24, 26, 28

            frame_id = 0

            progress_bar = st.progress(0)
            status_text = st.empty()

            while cap.isOpened():
                ret, frame = cap.read()
                if not ret:
                    break

                frame_id += 1
                t_s = frame_id / fps

                mp_img = mp.Image(image_format=mp.ImageFormat.SRGB,
                                  data=cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
                res = detector.detect_for_video(mp_img, int(t_s * 1000))

                if not res.pose_landmarks:
                    continue

                lm = res.pose_landmarks[0]
                P = lambda i: (int(lm[i].x * w), int(lm[i].y * h))

                if lm[LEL].visibility < 0.5 or lm[LWR].visibility < 0.5:
                    continue

                LS, LE, LW = P(LSH), P(LEL), P(LWR)
                LH, LK, LA = P(LHP), P(LKN), P(LAK)
                RH, RK, RA = P(RHP), P(RKN), P(RAK)
                NZ, RS = P(NOSE), P(RSH)

                elbow = angle(LS, LE, LW)
                kl = angle(LH, LK, LA)
                kr = angle(RH, RK, RA)

                elbow_buf.append(elbow)
                kl_buf.append(kl)
                kr_buf.append(kr)

                elbow_s = statistics.mean(elbow_buf)
                kl_s = statistics.mean(kl_buf)
                kr_s = statistics.mean(kr_buf)

                e_dev = deviation(elbow_s, IDEAL_ELBOW)
                kl_dev = deviation(kl_s, IDEAL_KNEE)
                kr_dev = deviation(kr_s, IDEAL_KNEE)
                symmetry = abs(kl_s - kr_s)

                raw_penalty = e_dev * 0.4 + symmetry * 0.4 + (kl_dev + kr_dev) * 0.2
                score = max(0, min(100, 100 - raw_penalty))
                score_buf.append(score)
                score = statistics.mean(score_buf)

                times.append(t_s)
                elbow_vals.append(elbow_s)
                kl_vals.append(kl_s)
                kr_vals.append(kr_s)
                sym_vals.append(symmetry)
                scores.append(score)

                elbow_win.append(elbow_s)
                time_win.append(t_s)
                if len(elbow_win) == elbow_win.maxlen:
                    is_min, _ = local_min_center(list(elbow_win), ELBOW_MIN_PROM)
                    ct = list(time_win)[len(time_win)//2]
                    if is_min and (not stroke_times or ct - stroke_times[-1] > MIN_STROKE_GAP_S):
                        stroke_times.append(ct)

                yaw = signed_yaw_proxy(NZ, LS, RS) * np.sign(RS[1] - LS[1] + 1e-6)
                yaw_series.append(yaw)

                desired = 'N'
                if yaw > BREATH_SIDE_THRESH: desired = 'R'
                elif yaw < -BREATH_SIDE_THRESH: desired = 'L'

                side_persist = side_persist + 1 if desired == current_side else 1
                current_side = desired

                if current_side in ('L','R') and side_persist >= MIN_BREATH_HOLD_FRAMES:
                    if t_s - last_breath_time > MIN_BREATH_GAP_S:
                        breath_count_L += current_side == 'L'
                        breath_count_R += current_side == 'R'
                        last_breath_time = t_s

                breath_state_series.append(current_side)

                # ── You can add drawing code here if you want annotated preview frames ──
                # For simplicity we skip heavy drawing in live preview

                frames_processed += 1
                if frames_processed % 30 == 0:
                    progress_bar.progress(min(0.99, frame_id / (cap.get(cv2.CAP_PROP_FRAME_COUNT) + 1)))
                    status_text.text(f"Processed {frame_id} frames...")

            cap.release()
            progress_bar.progress(1.0)
            status_text.text("Processing finished!")

            # ── Show summary metrics ──
            if len(stroke_times) >= 2:
                duration = max(1e-6, stroke_times[-1] - stroke_times[0])
                sr = 120.0 * (len(stroke_times)-1) / duration
            else:
                sr = 0.0

            total_time_min = max(1e-6, times[-1] if times else 1) / 60
            bpm = (breath_count_L + breath_count_R) / total_time_min

            col1, col2, col3 = st.columns(3)
            col1.metric("Stroke Rate", f"{sr:.1f} spm")
            col2.metric("Breath Rate", f"{bpm:.1f} bpm")
            col3.metric("Average Score", f"{np.mean(scores):.1f}/100" if scores else "—")

            st.info(f"Detected **{breath_count_L} left** + **{breath_count_R} right** breaths")

            # ── CSV download ──
            csv_buffer = io.StringIO()
            writer = csv.writer(csv_buffer)
            writer.writerow(["time","elbow","knee_L","knee_R","symmetry","score","yaw","breath"])
            for i in range(len(times)):
                writer.writerow([
                    round(times[i],2),
                    round(elbow_vals[i],1),
                    round(kl_vals[i],1),
                    round(kr_vals[i],1),
                    round(sym_vals[i],1),
                    round(scores[i],1),
                    round(yaw_series[i],3),
                    breath_state_series[i]
                ])

            st.download_button(
                label="Download results CSV",
                data=csv_buffer.getvalue(),
                file_name=f"swim_analysis_{ts}.csv",
                mime="text/csv"
            )

            # Optional: simple plot of elbow angle
            if len(times) > 10:
                fig, ax = plt.subplots()
                ax.plot(times, elbow_vals, label="Elbow angle (smoothed)")
                ax.set_xlabel("Time (s)")
                ax.set_ylabel("Angle (°)")
                ax.legend()
                st.pyplot(fig)

            os.unlink(VIDEO_PATH)  # clean up

    st.caption("Note: Annotated video generation is disabled to keep processing lighter. You can add it back if you have enough RAM/CPU.")